import {
  BadRequestException,
  Injectable,
  NotFoundException,
} from '@nestjs/common'
import { InjectorLoggerService } from 'modules/logger/InjectorLoggerService'
import { LoggerService } from 'modules/logger/logger.service'
import { InjectModel } from '@nestjs/mongoose'
import { IProperty, PropertyModelName } from 'common/schemas/Property.schema'
import mongoose, { Model } from 'mongoose'
import { CommonQueryFilter } from 'common/utils/query.filter'
import { CreatePropertyDto } from './dto/create-property.dto'
import { IOwner, OwnerModelName } from 'common/schemas/Owner.schema'
import { LocationModelName, ILocation } from 'common/schemas/Location.schema'
import {
  IPropertyType,
  PropertyTypeModelName,
} from 'common/schemas/PropertyType.schema'
import { GetPropertiesByOwnerDto } from './dto/getPropertiesByOwner.dto'
import { HighlightPropertyDto } from './dto/highlight-property.dto'
import { PropertyActivationDto } from './dto/property-activation.dto'
import { EditPropertyDto } from './dto/edit-property.dto'
import {
  IMessageOwner,
  MessageOwnerModelName,
} from 'common/schemas/Message_owner.schema'
import { IUser, UserModelName } from 'common/schemas/User.schema'
import { IPlan, PlanModelName } from 'common/schemas/Plan.schema'
import { generateRandomString } from 'common/utils/generateRandomPassword'
import { sendAutoGeneratedPasswordEmail } from 'common/utils/emailHandler'
import { AuthService } from 'modules/auth/auth.service'
import { SendAutoGeneratedPasswordDto } from 'common/utils/dto/send-auto-generated-password.dto'
import { TransformInstanceToInstance } from 'class-transformer'

export interface IDocsWithPagination {
  docs: IProperty[]
  totalPages: number
  page: number
  count?: number
}

export interface IPropertyByAnnouncementCode {
  announcementCode: string
}

export interface IOwnerPropertiesReturn {
  docs: IProperty[]
  messages: IMessageOwner[]
  totalPages: number
  count: number
}

export interface IFilterReturn {
  docs: IProperty[]
  page: number
  totalCount: number
  totalPages: number
}

export interface IFindByCodeReturn {
  docs: IProperty[]
}

interface IOwnerData {
  name: string
  phone: string
  cellPhone: string
  plan: any
  userId: any
  adCredits?: number
}

@Injectable()
export class PropertyService {
  constructor(
    @InjectorLoggerService(PropertyService.name)
    private readonly logger: LoggerService,
    @InjectModel(PropertyModelName)
    private readonly propertyModel: Model<IProperty>,
    @InjectModel(OwnerModelName)
    private readonly ownerModel: Model<IOwner>,
    @InjectModel(UserModelName)
    private readonly userModel: Model<IUser>,
    @InjectModel(PlanModelName)
    private readonly planModel: Model<IPlan>,
    @InjectModel(LocationModelName)
    private readonly locationModel: Model<ILocation>,
    @InjectModel(PropertyTypeModelName)
    private readonly propertyTypeModel: Model<IPropertyType>,
    @InjectModel(MessageOwnerModelName)
    private readonly messageModel: Model<IMessageOwner>,
    private readonly authService: AuthService,
  ) {}

  async findOne(id: string, isEdit: boolean): Promise<IProperty> {
    const session = await mongoose.startSession();
    session.startTransaction();
    try {
      this.logger.log({}, 'start findOne')

      const property: IProperty = await this.propertyModel.findById(id).lean()

      if (!property) {
        throw new NotFoundException(`O id: ${id} n√£o foi encontrado`)
      }

      // Incrementa o n√∫mero de visualiza√ß√µes do im√≥vel quando n√£o for p√°gina de edi√ß√£o de im√≥vel;
      if (!isEdit) {
        await this.propertyModel.updateOne(
          { _id: property._id },
          { $inc: { views: 1 } },
        )
      }

      await session.commitTransaction();

      return property
    } catch (error) {
      await session.abortTransaction();
      this.logger.error({
        error: JSON.stringify(error),
        exception: '> exception',
      })
      throw error
    } finally {
      session.endSession();
    }
  }

  async filter(queryFilter: CommonQueryFilter): Promise<IFilterReturn> {
    try {
      this.logger.log({}, 'start filter')

      const { page, limit, filter, sort } = queryFilter
      const originalPage = page + 1
      const highlightsSkip = page * limit

      const allFilters = this.getFilter(filter)

      // Querys $and n√£o aceitam arrays vazios, essa verifica√ß√£o muda o tipo de query caso o array allFilters esteja vazio;
      const filtersOrNot =
        allFilters.length > 1
          ? { $and: [...allFilters] }
          : { highlighted: false }

      let highlightsFilters
      const index = allFilters.findIndex(obj => obj.highlighted === false)
      if (index !== -1) {
        //Deep cloning foi necess√°rio pois o spread fazia com que o allFilters original tamb√©m fosse alterado;
        const clonedAllFilters = JSON.parse(JSON.stringify(allFilters))
        clonedAllFilters[index].highlighted = true
        highlightsFilters = clonedAllFilters
      }

      const countHighlights = await this.propertyModel.countDocuments({
        $and: highlightsFilters,
        highlighted: true,
      })

      // Busca os destaques considerando a ordena√ß√£o
      const highlights: IProperty[] = await this.propertyModel
        .find({ $and: highlightsFilters })
        .skip(highlightsSkip)
        .sort(sort[0])
        .limit(limit)
        .lean()

      const countDocs = await this.propertyModel.countDocuments(filtersOrNot)

      const propertySkipAux = (page + 1) * limit - countHighlights
      const propertyLimit = limit - highlights.length
      const propertySkip = propertyLimit === limit ? propertySkipAux - limit : 0

      // Busca os an√∫ncios comuns segundo a filtragem estabelecida;
      let docs: IProperty[] = []

      if (propertyLimit > 0) {
        docs = await this.propertyModel
          .find(filtersOrNot)
          .sort(sort[0])
          .skip(propertySkip)
          .limit(propertyLimit)
          .lean()
      }

      // insere os an√∫ncios em destaque no array de an√∫ncios comuns;
      docs.unshift(...highlights)

      let totalPages

      // Faz a contagem de p√°ginas e total de p√°ginas da busca para lidar com a pagina√ß√£o;
      if (queryFilter.need_count) {
        totalPages = Math.ceil((countDocs + countHighlights) / limit)
      }

      const totalCount = countDocs + countHighlights

      return {
        docs,
        page: originalPage,
        totalPages,
        totalCount,
      }
    } catch (error) {
      this.logger.error({
        error: JSON.stringify(error),
        exception: '> exception',
      })
      throw error
    }
  }

  async createOne(createPropertyDto: any): Promise<any> {
    const mongodbUri = process.env.DB_HOST;
    console.log("üöÄ ~ file: property.service.ts:215 ~ PropertyService ~ createOne ~ mongodbUri:", mongodbUri)
    const db = await mongoose.createConnection(mongodbUri).asPromise();
    const session = await db.startSession();

    try {
      const insert1 = await this.userModel.create({teste: true});
      console.log("üöÄ ~ file: property.service.ts:221 ~ PropertyService ~ createOne ~ insert1:", insert1)

      throw new Error('erro')

      await session.commitTransaction();
    } catch (error) {
      await session.abortTransaction();
      this.logger.error({
        error: JSON.stringify(error),
        exception: '> exception',
      })
      throw error
    } finally {
      session.endSession();
    }





    // try {
    //   this.logger.log({}, 'start createOne');

    //   const { propertyType, address } = createPropertyDto.propertyData

    //   const { plan, isPlanFree, phone, cellPhone, userData, propertyData } =
    //     createPropertyDto

    //   let cardName
    //   let cardNumber
    //   let cvc
    //   let expiry

    //   if (!isPlanFree) {
    //     cardName = createPropertyDto.creditCardData.cardName
    //     cardNumber = createPropertyDto.creditCardData.cardNumber
    //     cvc = createPropertyDto.creditCardData.cvc
    //     expiry = createPropertyDto.creditCardData.expiry
    //   }

    //   //Verifica se o id do usu√°rio foi passado na requisi√ß√£o (caso tenha criado o im√≥vel estando logado);
    //   const userId = userData._id ? userData._id : null
    //   let userAlreadyExists: boolean
    //   let user: IUser | null = null
    //   let owner: IOwner | null = null
    //   // Busca os dados do plano selecionado;
    //   const selectedPlan: IPlan = await this.planModel.findById(plan).lean()

    //   // USER

    //   if (userId) {
    //     user = await this.userModel.findById(userId).lean()

    //     //Indica que este usu√°rio j√° tem cadastro pr√©vio como 'user' no banco de dados;
    //     userAlreadyExists = true
    //   } else {
    //     //Verifica se apesar do usu√°rio n√£o estar logado ao criar o an√∫ncio o email dele j√° havia sido usado para cadastrar algum 'user' no banco de dados;
    //     const userEmailExists = await this.userModel.findOne({
    //       email: userData.email,
    //     })

    //     if (!userEmailExists) {
    //       // Gera uma senha provis√≥ria aleat√≥ria;
    //       const randomPassword: string = generateRandomString()

    //       const registerUserParams = {
    //         email: userData.email,
    //         password: randomPassword,
    //         passwordConfirmation: randomPassword,
    //       }

    //       const sendPasswordEmailParams: SendAutoGeneratedPasswordDto = {
    //         email: userData.email,
    //         username: userData.username,
    //         password: randomPassword,
    //       }

    //       const registerUser = await this.authService.register(
    //         registerUserParams,
    //       )

    //       await sendAutoGeneratedPasswordEmail(sendPasswordEmailParams)

    //       // Use o m√©todo updateOne para adicionar a propriedade 'cpf' ao usu√°rio
    //       await this.userModel.updateOne(
    //         { _id: registerUser._id }, // Filtro para encontrar o usu√°rio
    //         {
    //           cpf: userData.cpf,
    //           address: userData.address,
    //           username: userData.username,
    //         },
    //       )

    //       // Use o m√©todo findById para buscar o usu√°rio atualizado
    //       user = await this.userModel.findById(registerUser._id)
    //     } else {
    //       user = userEmailExists
    //     }
    //     userAlreadyExists = false
    //   }

    //   // OWNER

    //   // Verifica se o 'user' j√° √© um 'owner';
    //   const ownerExists: IOwner = await this.ownerModel.findOne({
    //     userId: user._id,
    //   })

    //   if (!ownerExists) {
    //     const ownerData: IOwnerData = {
    //       name: userData.username,
    //       phone,
    //       cellPhone,
    //       plan,
    //       userId: user._id,
    //       //adCredits: selectedPlan.commonAd,
    //     }

    //     if (!isPlanFree) {
    //       ownerData.adCredits = selectedPlan.commonAd
    //     }

    //     const createdOwner: IOwner = await this.ownerModel.create(ownerData)
    //     owner = createdOwner
    //   } else {
    //     owner = ownerExists

    //     // Atualiza o plano caso tenha sido alterado ao cadastrar o im√≥vel;
    //     const ownerPlan = owner.plan

    //     if (selectedPlan._id !== ownerPlan) {
    //       owner.plan = selectedPlan._id
    //       owner.adCredits = selectedPlan.commonAd
    //       if (selectedPlan.name === 'Locale Plus') {
    //         // Modificar o schema de owner para salvar o highlightCredit;
    //       }
    //       await owner.save()
    //     }
    //   }

    //   // CUSTOMER
    //   if (!isPlanFree && !owner.customerId) {
    //     // Cadastrar customer no payment api;
    //     const response = await fetch(`${process.env.PAYMENT_URL}/customer`, {
    //       method: 'POST',
    //       headers: {
    //         'Content-Type': 'application/json',
    //         access_token: process.env.ASSAS_API_KEY || '',
    //       },
    //       body: JSON.stringify({
    //         name: owner.name,
    //         email: userData.email,
    //         phone,
    //         postalCode: userData.address.zipCode,
    //         description: 'Confirma√ß√£o de cria√ß√£o de id de cliente',
    //         cpfCnpj: userData.cpf,
    //         addressNumber: address.streetNumber,
    //       }),
    //     })

    //     if (!response.ok) {
    //       throw new Error(`Falha ao criar o cliente: ${response.statusText}`)
    //     }

    //     const customer = await response.json()

    //     // Atualiza o 'customerId' no 'owner' e salva no banco de dados
    //     owner.customerId = customer.id
    //     await owner.save()
    //   }

    //   // PAYMENT

    //   let paymentValue
    //   let creditCardInfo
    //   // Validar se tem plano e se h√° creditos no plano;
    //   if (!isPlanFree) {
    //     if (owner.adCredits < 1) {
    //       throw new BadRequestException(
    //         `O usu√°rio n√£o tem mais cr√©ditos para criar um novo an√∫ncio.`,
    //       )
    //     }

    //     const formattedExpiry = expiry.split('-')
    //     const expiryYear = formattedExpiry[0]
    //     const expiryMonth = formattedExpiry[1]

    //     const currentDate = new Date()
    //     const year = currentDate.getFullYear()
    //     const month = (currentDate.getMonth() + 1).toString().padStart(2, '0')
    //     const day = currentDate.getDate().toString().padStart(2, '0')
    //     const formattedDate = `${year}-${month}-${day}`

    //     if (!owner.creditCardInfo.creditCardToken) {
    //       // Chamada pra api de pagamento "subscription";
    //       const response = await fetch(
    //         `${process.env.PAYMENT_URL}/payment/subscription`,
    //         {
    //           method: 'POST',
    //           headers: {
    //             'Content-Type': 'application/json',
    //             access_token: process.env.ASSAS_API_KEY || '',
    //           },
    //           body: JSON.stringify({
    //             billingType: 'CREDIT_CARD',
    //             cycle: 'MONTHLY',
    //             customer: owner.customerId,
    //             value: selectedPlan.price,
    //             nextDueDate: formattedDate,
    //             creditCard: {
    //               holderName: cardName,
    //               number: cardNumber,
    //               expiryMonth,
    //               expiryYear,
    //               ccv: cvc,
    //             },
    //             creditCardHolderInfo: {
    //               name: cardName,
    //               email: userData.email,
    //               phone,
    //               cpfCnpj: userData.cpf,
    //               postalCode: address.zipCode,
    //               addressNumber: address.streetNumber,
    //             },
    //           }),
    //         },
    //       )

    //       if (!response.ok) {
    //         throw new Error(`Falha ao gerar a cobran√ßa: ${response.statusText}`)
    //       }

    //       const responseData = await response.json()

    //       creditCardInfo = responseData.creditCard

    //       // Decrementar o n√∫mero de cr√©ditos dispon√≠veis do usu√°rio;
    //       owner.adCredits = owner.adCredits - 1
    //       // Salvar o token do cart√£o de cr√©dito no banco de dados;
    //       owner.creditCardInfo = creditCardInfo
    //       await owner.save()
    //     } else {
    //       if (owner.adCredits < 1) {
    //         // Chamada pra api de pagamento "subscription" no caso de o usu√°rio j√° ter seus dados de cart√£o salvos no banco;
    //         const response = await fetch(
    //           `${process.env.PAYMENT_URL}/payment/subscription`,
    //           {
    //             method: 'POST',
    //             headers: {
    //               'Content-Type': 'application/json',
    //               access_token: process.env.ASSAS_API_KEY || '',
    //             },
    //             body: JSON.stringify({
    //               billingType: 'CREDIT_CARD',
    //               cycle: 'MONTHLY',
    //               customer: owner.customerId,
    //               value: selectedPlan.price,
    //               nextDueDate: formattedDate,
    //               creditCardToken: owner.creditCardInfo.creditCardToken,
    //             }),
    //           },
    //         )

    //         if (!response.ok) {
    //           throw new Error(
    //             `Falha ao gerara cobran√ßa: ${response.statusText}`,
    //           )
    //         }
    //       }

    //       // Decrementar o n√∫mero de cr√©ditos dispon√≠veis do usu√°rio;
    //       owner.adCredits = owner.adCredits - 1
    //       await owner.save()
    //     }
    //   }

    //   // LOCATION

    //   // lida com o cadastro da cidade
    //   const foundCity = await this.locationModel
    //     .findOne({ name: address.city, category: 'city' })
    //     .lean()

    //   if (!foundCity) {
    //     await this.locationModel.create({
    //       name: address.city,
    //       category: 'city',
    //     })
    //   }

    //   // lida com o cadastro do estado
    //   const foundUf = await this.locationModel
    //     .findOne({ name: address.uf, category: 'uf' })
    //     .lean()

    //   if (!foundUf) {
    //     await this.locationModel.create({ name: address.uf, category: 'uf' })
    //   }

    //   // lida com o cadastro da rua
    //   const foundStreetName = await this.locationModel
    //     .findOne({ name: address.streetName, category: 'streetName' })
    //     .lean()

    //   if (!foundStreetName) {
    //     await this.locationModel.create({
    //       name: address.streetName,
    //       category: 'streetName',
    //     })
    //   }

    //   // Lida com o cadastro do bairro
    //   const foundNeighborhood = await this.locationModel
    //     .findOne({ name: address.neighborhood, category: 'neighborhood' })
    //     .lean()

    //   if (!foundNeighborhood) {
    //     await this.locationModel.create({
    //       name: address.neighborhood,
    //       category: 'neighborhood',
    //     })
    //   }

    //   // PROPERTY TYPE

    //   // lida com o cadastro do propertyType
    //   const foundPropertyType = await this.propertyTypeModel
    //     .findOne({ name: propertyType })
    //     .lean()

    //   if (!foundPropertyType) {
    //     await this.propertyTypeModel.create({ name: propertyType })
    //   }

    //   // PROPERTY

    //   propertyData.owner = owner._id

    //   propertyData.ownerInfo = {
    //     name: owner.name,
    //     phones: [phone, cellPhone],
    //   }

    //   // lida com a cria√ß√£o da property no DB
    //   const createdProperty = await this.propertyModel.create(propertyData);

    //   //await session.commitTransaction();

    //   return {
    //     createdProperty,
    //     creditCardBrand: owner.creditCardInfo.creditCardBrand,
    //     paymentValue,
    //     userAlreadyExists,
    //   }
    // } catch (error) {
    //   await session.abortTransaction();
    //   this.logger.error({
    //     error: JSON.stringify(error),
    //     exception: '> exception',
    //   })
    //   throw error
    // } finally {
    //   session.endSession();
    // }
  }

  async findByAnnouncementCode(
    announcementCode: string,
  ): Promise<IFindByCodeReturn> {
    try {
      this.logger.log({}, 'start findByAnnouncementCode')

      const foundAnnouncementCode: IProperty[] = await this.propertyModel
        .find({ announcementCode: announcementCode })
        .exec()

      if (foundAnnouncementCode.length == 0) {
        throw new NotFoundException(
          `O im√≥vel com o c√≥digo de an√∫ncio ${announcementCode} n√£o foi encontrado`,
        )
      }

      return { docs: foundAnnouncementCode }
    } catch (error) {
      this.logger.error({
        error: JSON.stringify(error),
        exception: '> exception',
      })
      throw error
    }
  }

  async findByOwner(
    getPropertiesByOwnerDto: GetPropertiesByOwnerDto,
  ): Promise<IOwnerPropertiesReturn> {
    try {
      this.logger.log({}, 'start find by owner')

      const { ownerId, page } = getPropertiesByOwnerDto
      const skip = (page - 1) * 10
      const limit = 10

      let ownerProperties: IProperty[]
      let count: number
      let totalPages: number

      // Verifica se o userId recebido √© um owner;

      const userIsOwner = await this.ownerModel.findById(ownerId)

      if (!userIsOwner) {
        ownerProperties = []
      } else {
        ownerProperties = await this.propertyModel
          .find({ owner: userIsOwner._id })
          .skip(skip)
          .limit(limit)
          .lean()

        count = await this.propertyModel.countDocuments({
          owner: userIsOwner._id,
        })
        totalPages = Math.ceil(count / limit)
      }

      const messages: IMessageOwner[] = await this.messageModel
        .find({ owner_id: ownerId })
        .lean()

      return {
        docs: ownerProperties,
        messages,
        totalPages,
        count,
      }
    } catch (error) {
      this.logger.error({
        error: JSON.stringify(error),
        exception: '> exception',
      })
      throw error
    }
  }

  async propertyActivation(propertyActivationDto: PropertyActivationDto) {
    try {
      this.logger.log({ propertyActivationDto }, 'start property activation')

      const { isActive, propertyId, userId } = propertyActivationDto

      const property = await this.propertyModel.find({ _id: propertyId }).lean()

      if (!property) {
        throw new NotFoundException(
          `Im√≥vel com o id: ${propertyId} n√£o encontrado.`,
        )
      }

      const propertyOwner = await this.ownerModel.findOne({ userId: userId })

      if (!propertyOwner) {
        throw new NotFoundException(
          `O anunciante com o id ${userId} n√£o foi encontrado.`,
        )
      }

      if (!isActive) {
        await this.propertyModel.updateOne(
          { _id: propertyId },
          { $set: { isActive: isActive } },
        )
      } else {
        if (propertyOwner.adCredits <= 0) {
          throw new BadRequestException(
            `O usu√°rio com o id ${userId} n√£o tem mais cr√©ditos para ativar esse an√∫ncio.`,
          )
        } else {
          await this.propertyModel.updateOne(
            { _id: propertyId },
            { $set: { isActive: isActive } },
          )

          await this.ownerModel.updateOne(
            { userId: userId },
            { $set: { adCredits: propertyOwner.adCredits - 1 } },
          )
        }
      }

      return {
        success: true,
        message: 'Propriedade atualizada com sucesso.',
      }
    } catch (error) {
      this.logger.error({
        error: JSON.stringify(error),
        exception: '> exception',
      })
      throw error
    }
  }

  async highlightProperty(highlightPropertyDto: HighlightPropertyDto) {
    try {
      this.logger.log({ highlightPropertyDto }, 'start highlight property')

      const { id, owner } = highlightPropertyDto

      const property = await this.propertyModel.find({ _id: id })

      if (!property) {
        throw new NotFoundException(`Im√≥vel com o id ${id} n√£o encontrado.`)
      }

      const propertyOwner = await this.ownerModel.findOne({ userId: owner })

      if (!propertyOwner) {
        throw new NotFoundException(
          `O anunciante com o id ${owner} n√£o foi encontrado.`,
        )
      }

      if (propertyOwner.adCredits <= 0) {
        throw new BadRequestException(`O propriet√°rio ${propertyOwner}`)
      }

      await this.propertyModel.updateOne(
        { _id: id },
        { $set: { highlighted: true } },
      )

      await this.ownerModel.updateOne(
        { _id: id },
        { $set: { adCredits: propertyOwner.adCredits - 1 } },
      )

      return {
        success: true,
        message: 'An√∫ncio destacado com sucesso.',
      }
    } catch (error) {
      this.logger.error({
        error: JSON.stringify(error),
        exception: '> exception',
      })
      throw error
    }
  }

  async editProperty(editPropertyDto: EditPropertyDto) {
    try {
      this.logger.log({}, 'start edit-property')

      const {
        id,
        adType,
        adSubtype,
        propertyType,
        propertySubtype,
        address,
        description,
        metadata,
        images,
        size,
        tags,
        condominiumTags,
        prices,
        youtubeLink,
      } = editPropertyDto

      const property = await this.propertyModel.findOne({ _id: id })

      if (!property) {
        throw new NotFoundException(
          `Nenhum im√≥vel foi encontrado para o id: ${id}`,
        )
      }

      const updatedProperty = await this.propertyModel.updateOne(
        { _id: id },
        {
          $set: {
            adType,
            adSubtype,
            propertyType,
            propertySubtype,
            address,
            description,
            metadata,
            images,
            size,
            tags,
            condominiumTags,
            prices,
            youtubeLink,
          },
        },
      )

      return updatedProperty
    } catch (error) {
      this.logger.error({
        error: JSON.stringify(error),
        exception: '> exception',
      })
      throw error
    }
  }

  getFilter(filter: any) {
    //Adiciona cada tipo de filtragem √† query;
    const allFilters = []

    filter.forEach(obj => {
      if (obj.adType) {
        allFilters.push({ adType: obj.adType })
      }
      if (obj.adSubtype) {
        allFilters.push({ adSubtype: obj.adSubtype })
      }
      if (obj.propertyType) {
        allFilters.push({
          propertyType: {
            $in: obj.propertyType,
          },
        })
      }
      if (obj.propertySubtype) {
        allFilters.push({ propertySubtype: obj.propertySubtype })
      }
      if (obj.announcementCode) {
        allFilters.push({ announcementCode: obj.announcementCode })
      }
      if (obj.bedroom) {
        allFilters.push({
          metadata: {
            $elemMatch: {
              type: 'bedroom',
              amount: { $gte: obj.bedroom },
            },
          },
        })
      }
      if (obj.bathroom) {
        allFilters.push({
          metadata: {
            $elemMatch: {
              type: 'bathroom',
              amount: { $gte: obj.bathroom },
            },
          },
        })
      }
      if (obj.parkingSpaces) {
        allFilters.push({
          metadata: {
            $elemMatch: {
              type: 'parkingSpaces',
              amount: { $gte: obj.parkingSpaces },
            },
          },
        })
      }
      if (obj.floors) {
        allFilters.push({
          metadata: {
            $elemMatch: {
              type: 'floors',
              amount: { $gte: obj.floors },
            },
          },
        })
      }
      if (obj.suites) {
        allFilters.push({
          metadata: {
            $elemMatch: {
              type: 'suites',
              amount: { $gte: obj.suites },
            },
          },
        })
      }
      if (obj.minPrice) {
        const formattedMinPrice = parseInt(obj.minPrice)
        allFilters.push({
          prices: {
            $elemMatch: {
              type: 'mensal',
              value: {
                $gte: formattedMinPrice,
              },
            },
          },
        })
      }
      if (obj.maxPrice) {
        const formattedMaxPrice = parseInt(obj.maxPrice)
        allFilters.push({
          prices: {
            $elemMatch: {
              type: 'mensal',
              value: {
                $lte: formattedMaxPrice,
              },
            },
          },
        })
      }
      if (obj.minCondominium) {
        allFilters.push({
          prices: {
            $elemMatch: {
              type: 'condominio',
              value: { $gte: parseInt(obj.minCondominium) },
            },
          },
        })
      }
      if (obj.maxCondominium) {
        allFilters.push({
          prices: {
            $elemMatch: {
              type: 'condominio',
              value: { $lte: parseInt(obj.maxCondominium) },
            },
          },
        })
      }
      if (obj.geolocation) {
        allFilters.push({
          geolocation: {
            $geoWithin: {
              $centerSphere: [
                [obj.geolocation.longitude, obj.geolocation.latitude],
                100 / 3963.2,
              ],
            },
          },
        })
      }
      if (obj.tags) {
        allFilters.push({
          tags: {
            $in: obj.tags,
          },
        })
      }
      if (obj.locationFilter && Array.isArray(obj.locationFilter)) {
        const locationFilters = obj.locationFilter
        const orQuery = []
        locationFilters.forEach(filter => {
          const { name, category } = filter
          if (name && category) {
            const query = {
              [`address.${category}`]: { $in: name },
            }
            orQuery.push(query)
          }
        })
        if (orQuery.length > 0) {
          allFilters.push({
            $or: orQuery,
          })
        }
      }
      if (obj.minSize) {
        allFilters.push({
          'size.area': { $gte: obj.minSize },
        })
      }
    })

    allFilters.push({
      highlighted: false,
    })

    return allFilters
  }
}
