import {
  BadRequestException,
  Injectable,
  LoggerService,
  NotFoundException,
} from '@nestjs/common'
import { InjectModel } from '@nestjs/mongoose'
import { PropertyModelName, IProperty } from 'common/schemas/Property.schema'
import { InjectorLoggerService } from 'modules/logger/InjectorLoggerService'
import mongoose, { Model } from 'mongoose'
import {
  CreatePropertyDto,
  CreditCardData,
  UserData,
} from '../dto/create-property.dto'
import { IOwner, OwnerModelName } from 'common/schemas/Owner.schema'
import { IPlan, PlanModelName } from 'common/schemas/Plan.schema'
import { IUser, UserModelName } from 'common/schemas/User.schema'
import { SendAutoGeneratedPasswordDto } from 'common/utils/dto/send-auto-generated-password.dto'
import { sendAutoGeneratedPasswordEmail } from 'common/utils/email/emailHandler'
import { generateRandomString } from 'common/utils/generateRandomPassword'
import { AuthService } from 'modules/auth/auth.service'
import { ILocation, LocationModelName } from 'common/schemas/Location.schema'
import {
  IPropertyType,
  PropertyTypeModelName,
} from 'common/schemas/PropertyType.schema'
import { TagModelName, ITag } from 'common/schemas/Tag.schema'
import axios from 'axios'
import { PropertyActivationDto } from '../dto/property-activation.dto'
import { CouponModelName, ICoupon } from 'common/schemas/Coupon.schema'
import { PlanTransitionDto } from 'modules/plan/dto/planTransition.dto'
import { ICreditCard } from 'modules/plan/dto/creditCard.dto'
import { SchedulerRegistry } from '@nestjs/schedule'
import { CronJob } from 'cron'

export interface IFormattedDate {
  formattedDate: string
  expiryYear: string
  expiryMonth: string
}

interface IOwnerData {
  _id?: string
  name: string
  phone: string
  cellPhone: string
  wwpNumber: string
  picture: string
  plan: any
  userId: any
  adCredits?: number
  highlightCredits?: number
  email: string
  isActive: boolean
  planTransitionStatus: string
  paymentData?: {
    subscriptionId: string
    cpfCnpj: string
    customerId: string
    creditCardInfo: {
      cardNumber: string
      cardBrand: string
      creditCardToken: string
    }
  }
}

@Injectable()
export class CreateProperty_Service {
  constructor(
    @InjectorLoggerService(CreateProperty_Service.name)
    private readonly logger: LoggerService,
    @InjectModel(PropertyModelName)
    private readonly propertyModel: Model<IProperty>,
    @InjectModel(UserModelName)
    private readonly userModel: Model<IUser>,
    @InjectModel(OwnerModelName)
    private readonly ownerModel: Model<IOwner>,
    @InjectModel(PlanModelName)
    private readonly planModel: Model<IPlan>,
    @InjectModel(LocationModelName)
    private readonly locationModel: Model<ILocation>,
    @InjectModel(PropertyTypeModelName)
    private readonly propertyTypeModel: Model<IPropertyType>,
    @InjectModel(TagModelName)
    private readonly tagModel: Model<ITag>,
    @InjectModel(CouponModelName)
    private readonly couponModel: Model<ICoupon>,
    private readonly authService: AuthService,
    private schedulerRegistry: SchedulerRegistry,
  ) {}

  async createOne(createPropertyDto: CreatePropertyDto): Promise<any> {
    const session = await this.startSession()
    try {
      await session.startTransaction()
      this.logger.log({}, 'start createOne')

      const {
        userData,
        propertyData,
        creditCardData,
        isPlanFree,
        plan,
        cellPhone,
        phone,
        deactivateProperties,
      } = createPropertyDto

      let coupon
      let updatedOwner

      if (createPropertyDto?.coupon) {
        coupon = createPropertyDto?.coupon
      }

      const { ownerInfo } = propertyData

      const {
        owner,
        userAlreadyExists,
        user,
        selectedPlan,
        ownerPreviousPlan,
      } = await this.getUserAndOwner(
        userData,
        phone,
        cellPhone,
        isPlanFree,
        plan,
        session,
        coupon,
      )

      const ownerActiveProperties = await this.propertyModel
        .find({ owner: owner._id, isActive: true })
        .lean()

      if (!coupon) {
        const { updatedOwner: tempUpdatedOwner } = await this.handleCustomer(
          isPlanFree,
          owner,
          userData,
          cellPhone,
          phone,
          creditCardData,
        )
        updatedOwner = tempUpdatedOwner
      }

      if (!isPlanFree) {
        if (
          ownerPreviousPlan?._id?.toString() !==
            selectedPlan?._id?.toString() &&
          ownerPreviousPlan !== undefined
        ) {
          if (!coupon) {
            const createPlanTransition = {
              owner: updatedOwner,
              user,
              prevPlan: ownerPreviousPlan,
              newPlan: selectedPlan,
              propertiesToDeactivate: deactivateProperties,
              creditCard: creditCardData,
              isCreate: true,
            }
            const planTransitionData = await this.createPlanTransition(
              createPlanTransition,
            )
            updatedOwner = {
              ...planTransitionData,
            }
          }
        } else {
          if (!updatedOwner) {
            updatedOwner = owner
          } else {
            updatedOwner.adCredits = updatedOwner.adCredits - 1
          }
        }
      } else {
        if (!isPlanFree) {
          if (owner && owner.adCredits === 0) {
            throw new BadRequestException(`O anunciante não tem mais créditos.`)
          }

          updatedOwner.paymentData.creditCardInfo = {
            creditCardBrand: '',
            creditCardNumber: '',
            creditCardToken: '',
          }
          updatedOwner.paymentData.subscriptionId = ''

          if (selectedPlan && selectedPlan._id !== ownerPreviousPlan._id) {
            updatedOwner = {
              ...updatedOwner,
              adCredits: (owner.adCredits - 1) + selectedPlan.adCredits,
            }
          } else {
            updatedOwner = {
              ...updatedOwner,
              adCredits: owner.adCredits - 1,
            }
          }
        } else {
          if (updatedOwner.adCredits > 0) {
            updatedOwner = await this.updateCredits(updatedOwner, selectedPlan)
          }
        }
      }

      if (!ownerPreviousPlan) {
        await this.ownerModel.create([updatedOwner], {
          session,
        })
      } else {
        await this.ownerModel.updateOne(
          { _id: updatedOwner?._id },
          { $set: updatedOwner },
          { session },
        )
      }

      // Deactivates the properties that the user choose in case that he changes his plan to a minor one;
      if (
        (deactivateProperties !== undefined &&
          deactivateProperties.length > 0) ||
        (selectedPlan.name === 'Free' &&
          ownerActiveProperties.length > 0 &&
          ownerPreviousPlan._id !== selectedPlan._id)
      ) {
        const deactivatepropertiesBody: PropertyActivationDto = {
          propertyId: [],
          userId: userData._id,
          isActive: false,
          session: session,
        }
        if (selectedPlan.name === 'Free' && ownerActiveProperties.length > 0) {
          ownerActiveProperties.forEach(e => {
            deactivatepropertiesBody.propertyId.push(e._id)
          })

          await this.activateDeactivateProperties(deactivatepropertiesBody)
        } else {
          deactivatepropertiesBody.propertyId = deactivateProperties
          await this.activateDeactivateProperties(deactivatepropertiesBody)
        }
      }

      await this.handleLocationCreation(propertyData.address, session)
      await this.handlePropertyTypeCreation(propertyData.propertyType, session)
      await this.handleTagsCreation(propertyData.tags)

      const createdProperty = await this.createProperty(
        propertyData,
        ownerInfo,
        owner._id,
      )

      await session.commitTransaction()

      return {
        createdProperty,
        creditCardBrand: owner?.paymentData?.creditCardInfo
          ? owner?.paymentData?.creditCardInfo?.creditCardBrand
          : null,
        paymentValue: null,
        userAlreadyExists,
        user,
      }
    } catch (error) {
      await session.abortTransaction()
      this.logger.error({
        error: JSON.stringify(error),
        exception: '> exception',
      })
      return { message: error.message }
    } finally {
      session.endSession()
    }
  }

  private async startSession() {
    const mongodbUri = `${process.env.DB_HOST}`
    const db = await mongoose.createConnection(mongodbUri).asPromise()
    return db.startSession()
  }

  private async getUserAndOwner(
    userData: any,
    phone: string,
    cellPhone: string,
    isPlanFree: boolean,
    plan: any,
    session: any,
    coupon?: string,
  ): Promise<any> {
    let userAlreadyExists: boolean
    let user: IUser | null = null
    let owner: any = null
    let ownerPreviousPlan
    let ownerData: IOwnerData

    const {
      _id: userId,
      email,
      username,
      address,
      cpf,
      wwpNumber,
      profilePicture,
    } = userData

    const plans = await this.planModel.find().lean()
    const plusPlan = plans.find(e => e.name === 'Locale Plus')
    const selectedPlan = plans.find(e => e._id.toString() === plan.toString())

    // Verificar se o usuário já está cadastrado
    if (userId) {
      user = await this.userModel.findById(userId).lean()

      if (!user || !user.isActive) {
        throw new NotFoundException(
          `O usuário com o id : ${userId} não foi encontrado.`,
        )
      }

      if (!user.address) {
        user = {
          ...user,
          address: address,
        }
        await this.userModel.updateOne({ _id: user._id }, { $set: user })
      }
    } else {
      // Verificar se o e-mail do usuário já existe no banco de dados
      const userEmailExists = await this.userModel.findOne({
        email,
        isActive: true,
      })

      if (!userEmailExists) {
        // Gerar uma senha aleatória para um novo usuário
        const randomPassword: string = generateRandomString()

        const registerUserParams = {
          email,
          password: randomPassword,
          passwordConfirmation: randomPassword,
        }

        const sendPasswordEmailParams: SendAutoGeneratedPasswordDto = {
          email,
          username,
          password: randomPassword,
        }

        // Registrar um novo usuário
        const registerUser = await this.authService.register(registerUserParams)
        await sendAutoGeneratedPasswordEmail(sendPasswordEmailParams)

        // Atualizar os dados do usuário no banco de dados
        await this.userModel.updateOne(
          { _id: registerUser._id },
          {
            cpf,
            address,
            username,
            email,
          },
          { session },
        )

        // Buscar o USER atualizado;
        user = await this.userModel.findById(registerUser._id)
      } else {
        user = userEmailExists
      }

      userAlreadyExists = false
    }

    // Verificar se o USER já é OWNER;
    const ownerExists = await this.ownerModel
      .findOne({
        userId: user._id,
        isActive: true,
      })
      .lean()

    if (!ownerExists) {
      // Criar um novo proprietário
      if (!coupon) {
        ownerData = {
          name: username,
          phone,
          cellPhone,
          wwpNumber,
          plan,
          picture: profilePicture,
          userId: user._id,
          email,
          isActive: true,
          adCredits: selectedPlan?.commonAd,
          highlightCredits: selectedPlan?.highlightAd,
          planTransitionStatus: 'none',
        }
      } else {
        ownerData = {
          name: username,
          phone,
          cellPhone,
          wwpNumber,
          plan: plusPlan._id,
          picture: profilePicture,
          userId: user._id,
          email,
          isActive: true,
          adCredits: plusPlan.commonAd,
          highlightCredits: plusPlan.highlightAd,
          planTransitionStatus: 'none',
        }
      }

      if (!isPlanFree && !coupon) {
        if (!selectedPlan) {
          throw new Error(`Plano com o id: ${plan} não encontrado.`)
        }

        ownerData.adCredits = selectedPlan.commonAd
        ownerData.highlightCredits = selectedPlan.highlightAd
      }

      owner = ownerData;

      if (coupon) {
        await this.couponModel.updateOne(
          { coupon },
          { $set: { isActive: false } },
          { session },
        )
      }
    } else {
      if (
        ownerExists.plan.toString() !== selectedPlan._id.toString() ||
        !ownerExists.plan
      ) {
        owner = ownerExists
        ownerPreviousPlan = plans.find(
          e => e._id.toString() === owner.plan.toString(),
        )
        owner.plan = selectedPlan._id
      } else {
        owner = ownerExists
        ownerPreviousPlan = plans.find(
          e => e._id.toString() === owner.plan.toString(),
        )
      }
    }

    return {
      owner,
      userAlreadyExists,
      user,
      selectedPlan,
      ownerPreviousPlan,
    }
  }

  private async handleCustomer(
    isPlanFree: boolean,
    owner: any,
    userData: UserData,
    cellPhone: string,
    phone: string,
    creditCardData: any,
  ) {
    try {
      let cpfCnpj: string
      const { address, email } = userData
      const { paymentData, name } = owner
      let updatedOwner = owner

      if (!isPlanFree && !paymentData?.customerId) {
        cpfCnpj = creditCardData?.cpfCnpj
        // Cadastrar customer no payment api;
        const response = await axios.post(
          `${process.env.PAYMENT_URL}/customer`,
          {
            name,
            email,
            phone: cellPhone,
            postalCode: address.zipCode,
            description: 'Confirmação de criação de id de cliente',
            cpfCnpj,
            addressNumber: address.streetNumber,
          },
          {
            headers: {
              'Content-Type': 'application/json',
              access_token: process.env.ASAAS_API_KEY || '',
            },
          },
        )

        if (response.status >= 200 && response.status < 300) {
          const customer = response.data

          updatedOwner = {
            ...owner,
            paymentData: {
              ...owner.paymentData,
              customerId: customer.id,
              cpfCnpj,
            },
          }

          return { updatedOwner }
        } else {
          throw new Error(`Falha ao criar o cliente: ${response.statusText}`)
        }
      } else if (isPlanFree && paymentData?.customerId) {
        // Deletar o customer;
        await axios.delete(
          `${process.env.PAYMENT_URL}/customer/${paymentData?.customerId}`,
        )

        delete updatedOwner.paymentData.customerId
      } else {
        updatedOwner = owner
      }

      return { updatedOwner }
    } catch (error) {
      throw new BadRequestException(
        `Houve um problema ao tentar acessar a API de pagamentos:`,
        error,
      )
    }
  }

  private async handlePayment(
    isPlanFree: boolean,
    selectedPlan: IPlan,
    owner: IOwner,
    userData: UserData,
    creditCardData: CreditCardData,
    cellPhone: string,
    ownerPreviousPlan: string,
    propertiesToDeactivate: number,
    ownerActiveProperties: number,
    creditsLeft: number | null,
    session: any,
  ) {
    let cpfCnpj: string
    let expiry: string
    let cardName: string
    let cardNumber: string
    let ccv: string

    let currentDate
    let year
    let month
    let day
    let formattedDate
    let expiryYear
    let expiryMonth

    let price
    let selectedPlanId

    let updatedOwner = { ...owner }

    const { address, email } = userData
    const { paymentData, adCredits, plan: ownerActualPlan } = owner
    const previousPlanData = await this.planModel.findById(ownerPreviousPlan)

    if (selectedPlan) {
      price = selectedPlan.price
      selectedPlanId = selectedPlan._id
    } else {
      price = previousPlanData?.price
      selectedPlanId = previousPlanData?._id
    }

    let newHighlightCredits

    if (creditCardData !== undefined) {
      cpfCnpj = creditCardData.cpfCnpj
      cardName = creditCardData.cardName
      cardNumber = creditCardData.cardNumber
      expiry = creditCardData.expiry
      ccv = creditCardData.ccv

      currentDate = new Date()
      year = currentDate.getFullYear()
      month = (currentDate.getMonth() + 1).toString().padStart(2, '0')
      day = currentDate.getDate().toString().padStart(2, '0')
      formattedDate = `${year}-${month}-${day}`
      expiryYear = `20${expiry[2] + expiry[3]}`
      expiryMonth = `${expiry[0] + expiry[1]}`
    }

    const planIdString = selectedPlanId.toString()
    const ownerActualPlanString = previousPlanData?._id.toString()

    // Usuário mudou de plano pago > pago;
    if (!isPlanFree && ownerActualPlanString !== planIdString) {
      if (!paymentData?.creditCardInfo?.creditCardToken) {
        const response = await axios.post(
          `${process.env.PAYMENT_URL}/payment/subscription`,
          {
            billingType: 'CREDIT_CARD',
            cycle: 'MONTHLY',
            customer: paymentData.customerId,
            value: price,
            nextDueDate: formattedDate,
            creditCard: {
              holderName: cardName,
              number: cardNumber,
              expiryMonth,
              expiryYear,
              ccv,
            },
            creditCardHolderInfo: {
              name: cardName,
              email,
              phone: cellPhone,
              cpfCnpj,
              postalCode: address.zipCode,
              addressNumber: address.streetNumber,
            },
          },
          {
            headers: {
              'Content-Type': 'application/json',
              access_token: process.env.ASAAS_API_KEY || '',
            },
          },
        )

        if (response.status >= 200 && response.status < 300) {
          // Se a resposta for bem-sucedida, manipule os dados da resposta
          const responseData = response.data

          // Atribuir os valores da resposta às variáveis
          const creditCardInfo = responseData.creditCard
          const subscriptionId = responseData.id

          // newAdCredits =
          //   selectedPlan.price > previousPlanData.price
          //     ? owner.adCredits + selectedPlan.commonAd
          //     : owner.adCredits - selectedPlan.commonAd - propertiesToDeactivate

          // newHighlightCredits =
          //   selectedPlan.price > previousPlanData.price
          //     ? owner.highlightCredits + selectedPlan.highlightAd
          //     : owner.highlightCredits - selectedPlan.highlightAd

          if (creditsLeft) {
            updatedOwner = {
              ...owner,
              plan: selectedPlan._id,
              adCredits: creditsLeft,
              highlightCredits: selectedPlan.highlightAd,
              paymentData: {
                ...owner.paymentData,
                creditCardInfo,
                subscriptionId,
              },
            }
          } else {
            updatedOwner = {
              ...owner,
              plan: selectedPlan._id,
              adCredits: selectedPlan.commonAd - 1,
              highlightCredits: selectedPlan.highlightAd,
              paymentData: {
                ...owner.paymentData,
                creditCardInfo,
                subscriptionId,
              },
            }
          }
        } else {
          throw new Error(`Falha ao gerar a cobrança: ${response.statusText}`)
        }
      } else {
        //Buscar a assinatura do usuário para verificar a data de cobrança e usar o token;
        const subscriptionId = owner.paymentData.subscriptionId
        const response = await axios.get(
          `${process.env.PAYMENT_URL}/payment/subscription/${subscriptionId}`,
          {
            headers: {
              'Content-Type': 'application/json',
              access_token: process.env.ASAAS_API_KEY || '',
            },
          },
        )

        if (response.status >= 200 && response.status < 300) {
          const subscription = response.data
          const nextDueDate = subscription.nextDueDate

          if (
            adCredits < 1 ||
            (adCredits === 0 && ownerActualPlanString !== planIdString)
          ) {
            // Caso em que o usuário não tem mais créditos e selecionou outro plano
            if (selectedPlanId !== ownerActualPlan) {
              const subscriptionId = paymentData.subscriptionId
              const priceDifference =
                price > previousPlanData.price
                  ? price - previousPlanData.price
                  : price

              const response = await axios.post(
                //Atualiza o valor do plano;
                `${process.env.PAYMENT_URL}/payment/update-subscription/${subscriptionId}`,
                {
                  billingType: 'CREDIT_CARD',
                  cycle: 'MONTHLY',
                  customer: paymentData.customerId,
                  value: priceDifference,
                  nextDueDate,
                  updatePendingPayments: true,
                  creditCardToken: paymentData.creditCardInfo.creditCardToken,
                },
                {
                  headers: {
                    'Content-Type': 'application/json',
                    access_token: process.env.ASAAS_API_KEY || '',
                  },
                  timeout: 100000,
                },
              )

              if (response.status <= 200 && response.status > 300) {
                throw new Error(
                  `Falha ao atualizar a assinatura: ${response.statusText}`,
                )
              }

              const responseData = response.data
              const updatedSubscriptionId = responseData.id
              const newAdcredits = owner.adCredits - 1 + selectedPlan.commonAd
              const newHighlightCredits =
                owner.highlightCredits > 0
                  ? owner.highlightCredits - 1 + selectedPlan.highlightAd
                  : owner.highlightCredits

              //Atualizar os créditos do usuário
              await this.ownerModel.updateOne(
                { _id: owner._id },
                {
                  $set: {
                    adCredits: newAdcredits,
                    highlightCredits: newHighlightCredits,
                    plan: selectedPlan._id,
                    'paymentData.subscriptionId': updatedSubscriptionId,
                  },
                },
                { session },
              )
            } else {
              throw new Error(
                `O usuário não tem mais créditos disponíveis para anunciar.`,
              )
            }
            // Chamada pra api de pagamento "subscription" para pagar a diferença de valor no caso de o usuário já ter seus dados de cartão salvos no banco;

            // To-do: Pra mostrar os dados do cartão na tela tem que usar SSL (HTTPS);

            // To-do: Implementar timeout de 60s para evitar duplicidade e bloqueio do cartão

            // To-do: Verificar a necessidade de passar o remoteIp do usuário na req;
            if (
              selectedPlan.price > previousPlanData.price &&
              previousPlanData.price > 0
            ) {
              const priceDifference =
                price > previousPlanData.price
                  ? price - previousPlanData.price
                  : price
              const response = await axios.post(
                `${process.env.PAYMENT_URL}/payment/subscription`,
                {
                  billingType: 'CREDIT_CARD',
                  cycle: 'MONTHLY',
                  customer: paymentData.customerId,
                  value: priceDifference,
                  dueDate: formattedDate,
                  creditCardToken: paymentData.creditCardInfo.creditCardToken,
                },
                {
                  headers: {
                    'Content-Type': 'application/json',
                    access_token: process.env.ASAAS_API_KEY || '',
                  },
                },
              )

              if (response.status <= 200 && response.status > 300) {
                throw new Error(
                  `Falha ao gerar a cobrança: ${response.statusText}`,
                )
              }
            }
          }

          try {
            // Fazer a atualização do plano
            await axios.post(
              `${process.env.PAYMENT_URL}/payment/update-subscription/${subscriptionId}`,
              {
                value: selectedPlan.price,
                updatePendingPayments: true,
                description: `Assinatura do plano ${selectedPlan.name}`,
              },
              {
                headers: {
                  'Content-Type': 'application/json',
                  access_token: process.env.ASAAS_API_KEY || '',
                },
              },
            )

            // Atualização dos créditos;
            if (typeof creditsLeft === 'number') {
              updatedOwner.adCredits = creditsLeft
            } else {
              updatedOwner.adCredits =
                selectedPlan.commonAd - 1 - ownerActiveProperties
              updatedOwner.plan = selectedPlan._id
            }
          } catch (error) {}
        } else {
          throw new NotFoundException('Assinatura não encontrada.')
        }
      }
    } else {
      // Usuário selecionou o plano grátis ou o mesmo plano que já tem;
      if (owner.adCredits > 0) {
        // Fazer a assinatura caso ainda não tenha;
        if (!owner?.paymentData?.subscriptionId && !isPlanFree) {
          const response = await axios.post(
            `${process.env.PAYMENT_URL}/payment/subscription`,
            {
              billingType: 'CREDIT_CARD',
              cycle: 'MONTHLY',
              customer: paymentData.customerId,
              value: price,
              nextDueDate: formattedDate,
              creditCard: {
                holderName: cardName,
                number: cardNumber,
                expiryMonth,
                expiryYear,
                ccv,
              },
              creditCardHolderInfo: {
                name: cardName,
                email,
                phone: cellPhone,
                cpfCnpj,
                postalCode: address.zipCode,
                addressNumber: address.streetNumber,
              },
            },
            {
              headers: {
                'Content-Type': 'application/json',
                access_token: process.env.ASAAS_API_KEY || '',
              },
            },
          )

          if (response.status >= 200 && response.status < 300) {
            // Se a resposta for bem-sucedida, manipule os dados da resposta
            const responseData = response.data

            // Atribuir os valores da resposta às variáveis
            const creditCardInfo = responseData.creditCard
            const subscriptionId = responseData.id
            updatedOwner.paymentData.subscriptionId = subscriptionId

            // Condicional dos créditos para casos em que já havia um plano anterior ou não;
            if (!previousPlanData) {
              // newAdCredits = selectedPlan.commonAd
              newHighlightCredits = selectedPlan.highlightAd
            } else if (ownerActualPlanString !== planIdString) {
              // newAdCredits =
              //   selectedPlan.price > previousPlanData.price
              //     ? owner.adCredits + selectedPlan.commonAd
              //     : owner.adCredits - selectedPlan.commonAd

              newHighlightCredits =
                selectedPlan.price > previousPlanData.price
                  ? owner.highlightCredits + selectedPlan.highlightAd
                  : owner.highlightCredits - selectedPlan.highlightAd
            }

            updatedOwner = {
              ...owner,
              plan: selectedPlan._id,
              adCredits: owner.adCredits - 1,
              highlightCredits: newHighlightCredits,
              paymentData: {
                ...owner.paymentData,
                creditCardInfo,
                subscriptionId,
              },
            }
          } else {
            updatedOwner = {
              ...owner,
              adCredits: owner.adCredits - 1,
            }
          }
        } else {
          if (owner.paymentData?.subscriptionId) {
            // Cancelar a assinatura
            const { data } = await axios.delete(
              `${process.env.PAYMENT_URL}/payment/subscription/${owner?.paymentData?.subscriptionId}`,
              {
                method: 'DELETE',
                headers: {
                  'Content-Type': 'application/json',
                  access_token: process.env.ASSAS_API_KEY || '',
                },
              },
            )

            const success = data.deleted

            if (!success) {
              throw new Error('Não foi possível remover a assinatura')
            }

            updatedOwner.paymentData.creditCardInfo = {
              creditCardBrand: '',
              creditCardNumber: '',
              creditCardToken: '',
            }
            updatedOwner.paymentData.subscriptionId = ''

            updatedOwner = {
              ...updatedOwner,
              adCredits: owner.adCredits - 1,
            }
          } else {
            updatedOwner = {
              ...updatedOwner,
              adCredits: owner.adCredits - 1,
              highlightCredits: 0,
            }
          }
        }
      } else {
        throw new BadRequestException(
          `Não há mais créditos para fazer anúncios`,
        )
      }
    }

    return updatedOwner
  }

  private async handleLocationCreation(address: any, session: any) {
    await this.createOrUpdateLocation('city', address.city, session)
    await this.createOrUpdateLocation('uf', address.uf, session)
    await this.createOrUpdateLocation('streetName', address.streetName, session)
    await this.createOrUpdateLocation(
      'neighborhood',
      address.neighborhood,
      session,
    )
  }

  private async createOrUpdateLocation(
    category: string,
    name: string,
    session: any,
  ) {
    const foundLocation = await this.locationModel
      .findOne({ name, category })
      .lean()

    if (!foundLocation) {
      // Se a localização não existir, criar uma nova
      await this.locationModel.create([{ name, category }], { session })
    } else {
      // Se a localização já existir, não é necessário fazer nada
      return
    }
  }

  private async handlePropertyTypeCreation(propertyType: any, session: any) {
    const foundPropertyType = await this.propertyTypeModel
      .findOne({ name: propertyType })
      .lean()

    if (!foundPropertyType) {
      // Se o tipo de propriedade não existir, criar um novo
      await this.propertyTypeModel.create([{ name: propertyType }], { session })
    } else {
      // Se o tipo de propriedade já existir, não é necessário fazer nada
      return
    }
  }

  private async handleTagsCreation(tags: any[]) {
    if (tags && tags.length > 0) {
      const tagObjects: any = tags.map(tag => ({
        updateOne: {
          filter: { name: tag },
          update: {
            $inc: { amount: 1 },
          },
          upsert: true,
        },
      }))

      await this.tagModel.bulkWrite(tagObjects)
    }
  }

  private async createProperty(
    propertyData: any,
    ownerInfo: any,
    ownerId: string,
  ) {
    propertyData.owner = ownerId
    propertyData.ownerInfo = { ...ownerInfo, picture: '' }

    const createdProperty = await this.propertyModel.create(propertyData)

    return createdProperty
  }

  async activateDeactivateProperties(
    propertyActivationDto: PropertyActivationDto,
  ) {
    try {
      const { isActive, propertyId, userId, session } = propertyActivationDto

      const propertyOwner = await this.ownerModel
        .findOne({
          userId: userId,
          isActive: true,
        })
        .lean()

      if (!propertyOwner) {
        throw new NotFoundException(
          `O anunciante com o id ${userId} não foi encontrado.`,
        )
      }

      // Verifica se algum dos ids passados não é válido;
      if (propertyId.length > 0) {
        propertyId.forEach(async id => {
          const property = await this.propertyModel
            .find({ _id: id, isActive: false })
            .lean()

          if (!property) {
            throw new NotFoundException(
              `Imóvel com o id: ${propertyId} não encontrado.`,
            )
          }
        })
      }

      // Mudar os não selecionados para inativo?
      if (!isActive) {
        await this.propertyModel.updateMany(
          { _id: { $in: propertyId } },
          { $set: { isActive: isActive } },
          session,
        )
      } else {
        if (!propertyOwner.adCredits || propertyOwner.adCredits <= 0) {
          throw new BadRequestException(
            `O usuário com o id ${userId} não tem mais créditos para ativar esse anúncio.`,
          )
        } else {
          await this.propertyModel.updateMany(
            { _id: { $in: propertyId } },
            { $set: { isActive: isActive } },
            session,
          )

          await this.ownerModel.updateOne(
            { userId: userId },
            { $set: { adCredits: propertyOwner.adCredits - 1 } },
            session,
          )
        }
      }
    } catch (error) {
      throw new Error(`Não foi possível desativar os imóveis do usuário.`)
    }
  }

  async createPlanTransition(
    planTransitionDto: PlanTransitionDto,
  ): Promise<IOwner> {
    try {
      this.logger.log({}, 'start create plan transition > [plan service]')

      const { owner, user, prevPlan, newPlan, creditCard } = planTransitionDto

      let updatedOwner: any = owner

      // Upgrade;
      if (newPlan.price > prevPlan.price) {
        if (owner.paymentData?.subscriptionId) {
          // Atualizar a assinatura do pagamento junto a Asaas;
          await this.updateSubscription(owner, newPlan)
        } else {
          // Criar a assinatura do pagamento junto a Asaas;
          const { subscriptionId, creditCardInfo } =
            await this.createSubscription(user, owner, newPlan, creditCard)

          updatedOwner = {
            ...updatedOwner,
            paymentData: {
              ...updatedOwner.paymentData,
              subscriptionId,
              creditCardInfo,
              cpfCnpj: creditCard.cpfCnpj,
            },
          }
        }
      } else {
        // Downgrade;
        await this.updateSubscription(owner, newPlan)
      }

      updatedOwner = await this.updateCredits(updatedOwner, newPlan)

      return updatedOwner
    } catch (error) {
      this.logger.error({
        error: JSON.stringify(error),
        exception: '> exception',
      })
      throw error
    }
  }

  async updateSubscription(owner: IOwner, newPlan: IPlan) {
    try {
      this.logger.log({}, 'update payment subscription > [plan service]')

      const { paymentData } = owner
      const { price, name } = newPlan

      const subscriptionId = paymentData.subscriptionId

      await axios.post(
        `${process.env.PAYMENT_URL}/payment/update-subscription/${subscriptionId}`,
        {
          value: price,
          updatePendingPayments: true,
          description: `Assinatura do plano ${name}`,
        },
        {
          headers: {
            'Content-Type': 'application/json',
            access_token: process.env.ASAAS_API_KEY || '',
          },
        },
      )
    } catch (error) {
      this.logger.error({
        error: JSON.stringify(error),
        exception: '> exception',
      })
      throw error
    }
  }

  async createSubscription(
    user: IUser,
    owner: IOwner,
    plan: IPlan,
    creditCard: ICreditCard,
  ): Promise<{ subscriptionId: string; creditCardInfo: any }> {
    try {
      this.logger.log({}, 'create payment subscription > [plan service]')

      const { paymentData, cellPhone: phone } = owner
      const { username: holderName, email, address } = user
      const { price: value } = plan
      const { cardName: name, cardNumber: number, expiry, ccv } = creditCard
      const { formattedDate, expiryMonth, expiryYear } =
        this.getFormattedDate(expiry)

      const { data } = await axios.post(
        `${process.env.PAYMENT_URL}/payment/subscription`,
        {
          billingType: 'CREDIT_CARD',
          cycle: 'MONTHLY',
          customer: paymentData.customerId,
          value,
          nextDueDate: formattedDate,
          creditCard: {
            holderName,
            number,
            expiryMonth,
            expiryYear,
            ccv,
          },
          creditCardHolderInfo: {
            name,
            email,
            phone,
            cpfCnpj: paymentData.cpfCnpj
              ? paymentData.cpfCnpj
              : creditCard.cpfCnpj,
            postalCode: address.zipCode,
            addressNumber: address.streetNumber,
          },
        },
        {
          headers: {
            'Content-Type': 'application/json',
            access_token: process.env.ASAAS_API_KEY || '',
          },
          timeout: 3000000,
        },
      )

      return {
        subscriptionId: data.id,
        creditCardInfo: data.creditCard,
      }
    } catch (error) {
      this.logger.error({
        error: JSON.stringify(error),
        exception: '> exception',
      })
      throw error
    }
  }

  getFormattedDate(expiry: string): IFormattedDate {
    const currentDate = new Date()
    const year = currentDate.getFullYear()
    const month = (currentDate.getMonth() + 1).toString().padStart(2, '0')
    const day = currentDate.getDate().toString().padStart(2, '0')
    const formattedDate = `${year}-${month}-${day}`
    const expiryYear = `20${expiry[2] + expiry[3]}`
    const expiryMonth = `${expiry[0] + expiry[1]}`

    return {
      formattedDate,
      expiryYear,
      expiryMonth,
    }
  }

  async updateCredits(owner: IOwnerData, newPlan: IPlan): Promise<any> {
    try {
      const { paymentData, _id } = owner

      let updatedOwner = owner
      let newAdCredits
      const newHighlightCredits = owner.highlightCredits + newPlan.highlightAd

      // Verificar se apesar do plano ser grátis o owner ainda possuia créditos de outro plano anterior;
      if (owner.plan.toString() !== newPlan._id.toString()) {
        newAdCredits = owner.adCredits + newPlan.commonAd
      } else {
        newAdCredits = owner.adCredits - 1
      }

      if (paymentData?.customerId) {
        // Buscar data de vencimento;
        const { data } = await axios.get(
          `${process.env.PAYMENT_URL}/payment/subscription/${paymentData?.subscriptionId}`,
          {
            headers: {
              'Content-Type': 'application/json',
              access_token: process.env.ASAAS_API_KEY || '',
            },
            timeout: 3000000,
          },
        )

        const updateDate = new Date(data.nextDueDate)

        // Lógica de mudança de créditos imediata;
        updatedOwner = {
          ...owner,
          adCredits: newAdCredits,
          highlightCredits: newHighlightCredits,
          planTransitionStatus: 'processing',
        }

        // Verificar se já existe um cron job com este ID
        if (this.schedulerRegistry.doesExist('cron', _id.toString())) {
          // Se existe, deletar o cron job atual
          this.schedulerRegistry.deleteCronJob(_id.toString())
          this.logger.debug(`Job anterior para o anunciante ${_id} deletado`)
        }

        // Criar novo cron job
        const job = new CronJob(updateDate, async () => {
          await this.ownerModel.updateOne(
            { _id },
            {
              $set: {
                adCredits: newAdCredits - owner.adCredits,
                highlightCredits: newHighlightCredits - owner.highlightCredits,
                planTransitionStatus: 'complete',
              },
            },
          )
          this.logger.debug(`Anunciante ${_id} atualizado`)
          this.schedulerRegistry.deleteCronJob(_id.toString()) // remove o job após execução
        })

        this.schedulerRegistry.addCronJob(_id.toString(), job)
        job.start()
        this.logger.debug(
          `Job para o anunciante ${_id} agendado para: ${updateDate}`,
        )
      } else {
        updatedOwner.adCredits = newAdCredits
      }

      return updatedOwner
    } catch (error) {
      throw error
    }
  }
}
