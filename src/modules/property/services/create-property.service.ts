import {
  BadRequestException,
  Injectable,
  LoggerService,
  NotFoundException,
} from '@nestjs/common'
import { InjectModel } from '@nestjs/mongoose'
import { PropertyModelName, IProperty } from 'common/schemas/Property.schema'
import { InjectorLoggerService } from 'modules/logger/InjectorLoggerService'
import mongoose, { Model } from 'mongoose'
import {
  CreatePropertyDto,
  CreditCardData,
  UserData,
} from '../dto/create-property.dto'
import { IOwner, OwnerModelName } from 'common/schemas/Owner.schema'
import { IPlan, PlanModelName } from 'common/schemas/Plan.schema'
import { IUser, UserModelName } from 'common/schemas/User.schema'
import { SendAutoGeneratedPasswordDto } from 'common/utils/dto/send-auto-generated-password.dto'
import { sendAutoGeneratedPasswordEmail } from 'common/utils/emailHandler'
import { generateRandomString } from 'common/utils/generateRandomPassword'
import { AuthService } from 'modules/auth/auth.service'
import { ILocation, LocationModelName } from 'common/schemas/Location.schema'
import {
  IPropertyType,
  PropertyTypeModelName,
} from 'common/schemas/PropertyType.schema'
import { TagModelName, ITag } from 'common/schemas/Tag.schema'
import axios from 'axios'

interface IOwnerData {
  name: string
  phone: string
  cellPhone: string
  wppNumber: string
  picture: string
  plan: any
  userId: any
  adCredits?: number
  highlightCredits?: number
  email: string
}

@Injectable()
export class CreateProperty_Service {
  constructor(
    @InjectorLoggerService(CreateProperty_Service.name)
    private readonly logger: LoggerService,
    @InjectModel(PropertyModelName)
    private readonly propertyModel: Model<IProperty>,
    @InjectModel(UserModelName)
    private readonly userModel: Model<IUser>,
    @InjectModel(OwnerModelName)
    private readonly ownerModel: Model<IOwner>,
    @InjectModel(PlanModelName)
    private readonly planModel: Model<IPlan>,
    @InjectModel(LocationModelName)
    private readonly locationModel: Model<ILocation>,
    @InjectModel(PropertyTypeModelName)
    private readonly propertyTypeModel: Model<IPropertyType>,
    @InjectModel(TagModelName)
    private readonly tagModel: Model<ITag>,
    private readonly authService: AuthService,
  ) {}

  async createOne(createPropertyDto: CreatePropertyDto): Promise<any> {
    const session = await this.startSession()

    try {
      await session.startTransaction()
      this.logger.log({}, 'start createOne')

      const {
        userData,
        propertyData,
        creditCardData,
        isPlanFree,
        plan,
        cellPhone,
      } = createPropertyDto

      const { ownerInfo } = propertyData

      const {
        owner,
        userAlreadyExists,
        user,
        selectedPlan,
        ownerPreviousPlan,
      } = await this.getUserAndOwner(userData, isPlanFree, plan, session)

      await this.handleCustomer(
        isPlanFree,
        owner,
        userData,
        cellPhone,
        creditCardData,
      )

      if (!isPlanFree) {
        await this.handlePayment(
          isPlanFree,
          selectedPlan,
          owner,
          userData,
          creditCardData,
          cellPhone,
          ownerPreviousPlan,
        )
      }

      await this.handleLocationCreation(propertyData.address, session)
      await this.handlePropertyTypeCreation(propertyData.propertyType, session)
      await this.handleTagsCreation(propertyData.tags)

      const createdProperty = await this.createProperty(
        propertyData,
        ownerInfo,
        owner._id,
      )

      await session.commitTransaction()

      return {
        createdProperty,
        creditCardBrand: owner.paymentData.creditCardInfo
          ? owner.paymentData.creditCardInfo.creditCardBrand
          : null,
        paymentValue: null,
        userAlreadyExists,
        user,
      }
    } catch (error) {
      await session.abortTransaction()
      this.logger.error({
        error: JSON.stringify(error),
        exception: '> exception',
      })
      throw error
    } finally {
      session.endSession()
    }
  }

  private async startSession() {
    const mongodbUri = `${process.env.DB_HOST}`
    const db = await mongoose.createConnection(mongodbUri).asPromise()
    return db.startSession()
  }

  private async getUserAndOwner(
    userData: any,
    isPlanFree: boolean,
    plan: any,
    session: any,
  ): Promise<any> {
    let userAlreadyExists: boolean
    let user: IUser | null = null
    let owner: IOwner | null = null
    let ownerPreviousPlan

    const {
      _id: userId,
      email,
      username,
      address,
      cpf,
      phone,
      cellPhone,
      wppNumber,
      profilePicture,
    } = userData

    // Verificar se o usuário já está cadastrado
    if (userId) {
      user = await this.userModel.findById(userId).lean()

      if (!user || !user.isActive) {
        throw new NotFoundException(
          `O usuário com o id : ${userId} não foi encontrado.`,
        )
      }

      userAlreadyExists = true
    } else {
      // Verificar se o e-mail do usuário já existe no banco de dados
      const userEmailExists = await this.userModel.findOne({
        email,
        isActive: true,
      })

      if (!userEmailExists) {
        // Gerar uma senha aleatória para um novo usuário
        const randomPassword: string = generateRandomString()

        const registerUserParams = {
          email,
          password: randomPassword,
          passwordConfirmation: randomPassword,
        }

        const sendPasswordEmailParams: SendAutoGeneratedPasswordDto = {
          email,
          username,
          password: randomPassword,
        }

        // Registrar um novo usuário
        const registerUser = await this.authService.register(registerUserParams)
        await sendAutoGeneratedPasswordEmail(sendPasswordEmailParams)

        // Atualizar os dados do usuário no banco de dados
        await this.userModel.updateOne(
          { _id: registerUser._id },
          {
            cpf,
            address,
            username,
            email,
          },
          { session },
        )

        // Buscar o usuário atualizado
        user = await this.userModel.findById(registerUser._id)
      } else {
        user = userEmailExists
      }

      userAlreadyExists = false
    }

    // Verificar se o usuário já é proprietário
    const ownerExists = await this.ownerModel.findOne({
      userId: user._id,
      isActive: true,
    })

    let selectedPlan: IPlan

    if (!ownerExists) {
      // Criar um novo proprietário
      const ownerData: IOwnerData = {
        name: username,
        phone,
        cellPhone,
        wppNumber,
        plan,
        picture: profilePicture,
        userId: user._id,
        email,
        adCredits: 0,
        highlightCredits: 0,
      }

      if (!isPlanFree) {
        selectedPlan = await this.planModel.findById(plan).lean()
        ownerData.adCredits = selectedPlan.commonAd
        ownerData.highlightCredits = selectedPlan.highlightAd
      }

      const createdOwner = await this.ownerModel.create([ownerData], {
        session,
      })
      owner = createdOwner[0]
    } else {
      owner = ownerExists
      ownerPreviousPlan = ownerExists.plan
    }

    return {
      owner,
      userAlreadyExists,
      user,
      selectedPlan,
      ownerPreviousPlan,
      selectedPlanData: selectedPlan,
    }
  }

  private async handleCustomer(
    isPlanFree: boolean,
    owner: IOwner,
    userData: UserData,
    cellPhone: string,
    creditCardData: any,
  ) {
    let cpfCnpj: string
    const { address, email } = userData
    const { paymentData, name } = owner

    if (!isPlanFree && !paymentData.customerId) {
      cpfCnpj = creditCardData.cpfCnpj
      // Cadastrar customer no payment api;
      const response = await axios.post(
        `${process.env.PAYMENT_URL}/customer`,
        {
          name,
          email,
          phone: cellPhone,
          postalCode: address.zipCode,
          description: 'Confirmação de criação de id de cliente',
          cpfCnpj,
          addressNumber: address.streetNumber,
        },
        {
          headers: {
            'Content-Type': 'application/json',
            access_token: process.env.ASAAS_API_KEY || '',
          },
        },
      )

      if (response.status >= 200 && response.status < 300) {
        const customer = response.data

        // Atualiza o 'customerId' no 'owner' e salva no banco de dados
        paymentData.customerId = customer.id
        paymentData.cpfCnpj = cpfCnpj
        await owner.save()
      } else {
        throw new Error(`Falha ao criar o cliente: ${response.statusText}`)
      }
    }
  }

  private async handlePayment(
    isPlanFree: boolean,
    selectedPlan: IPlan,
    owner: IOwner,
    userData: UserData,
    creditCardData: CreditCardData,
    cellPhone: string,
    ownerPreviousPlan: string,
  ) {
    let cpfCnpj: string
    let expiry: string
    let cardName: string
    let cardNumber: string
    let ccv: string

    const { address, email } = userData
    const { paymentData, adCredits, plan: ownerActualPlan } = owner
    const { price, _id: planId } = selectedPlan

    if (creditCardData !== undefined) {
      cpfCnpj = creditCardData.cpfCnpj
      cardName = creditCardData.cardName
      cardNumber = creditCardData.cardNumber
      expiry = creditCardData.expiry
      ccv = creditCardData.ccv
    }

    if (!isPlanFree) {
      if (adCredits < 1) {
        throw new BadRequestException(
          `O usuário não tem mais créditos para criar um novo anúncio.`,
        )
      }

      const expiryYear = `20${expiry[2] + expiry[3]}`
      const expiryMonth = `${expiry[0] + expiry[1]}`

      const currentDate = new Date()
      const year = currentDate.getFullYear()
      const month = (currentDate.getMonth() + 1).toString().padStart(2, '0')
      const day = currentDate.getDate().toString().padStart(2, '0')
      const formattedDate = `${year}-${month}-${day}`

      if (!paymentData.creditCardInfo.creditCardToken) {
        const response = await axios.post(
          `${process.env.PAYMENT_URL}/payment/subscription`,
          {
            billingType: 'CREDIT_CARD',
            cycle: 'MONTHLY',
            customer: paymentData.customerId,
            value: price,
            nextDueDate: formattedDate,
            creditCard: {
              holderName: cardName,
              number: cardNumber,
              expiryMonth,
              expiryYear,
              ccv,
            },
            creditCardHolderInfo: {
              name: cardName,
              email: email,
              phone: cellPhone,
              cpfCnpj,
              postalCode: address.zipCode,
              addressNumber: address.streetNumber,
            },
          },
          {
            headers: {
              'Content-Type': 'application/json',
              access_token: process.env.ASAAS_API_KEY || '',
            },
          },
        )

        if (response.status >= 200 && response.status < 300) {
          // Se a resposta for bem-sucedida, manipule os dados da resposta
          const responseData = response.data

          // Atribuir os valores da resposta às variáveis
          const creditCardInfo = responseData.creditCard
          const subscriptionId = responseData.id

          // Decrementar o número de créditos disponíveis do usuário
          owner.adCredits = owner.adCredits - 1

          // Salvar o token do cartão de crédito no banco de dados
          owner.paymentData.creditCardInfo = creditCardInfo
          owner.paymentData.subscriptionId = subscriptionId

          // Salvar as alterações no banco de dados
          await owner.save()
        } else {
          // Se a resposta não for bem-sucedida, lançar um erro
          throw new Error(`Falha ao gerar a cobrança: ${response.statusText}`)
        }
      } else {
        //Buscr a assinatura do usuário para verificar a data de cobrança;
        const subscriptionId = owner.paymentData.subscriptionId
        const response = await axios.get(
          `${process.env.PAYMENT_URL}/payment/subscription/${subscriptionId}`,
          {
            headers: {
              'Content-Type': 'application/json',
              access_token: process.env.ASAAS_API_KEY || '',
            },
          },
        )

        if (response.status >= 200 && response.status < 300) {
          const subscription = response.data
          const nextDueDate = subscription.nextDueDate

          if (adCredits < 1) {
            // Caso em que o usuário não tem mais créditos e selecionou outro plano
            if (planId !== ownerActualPlan) {
              const subscriptionId = paymentData.subscriptionId
              const response = await axios.post(
                //Atualiza o valor do plano;
                `${process.env.PAYMENT_URL}/payment/subscription/${subscriptionId}`,
                {
                  billingType: 'CREDIT_CARD',
                  cycle: 'MONTHLY',
                  customer: paymentData.customerId,
                  value: price,
                  nextDueDate,
                  updatePendingPayments: true,
                  creditCardToken: paymentData.creditCardInfo.creditCardToken,
                },
                {
                  headers: {
                    'Content-Type': 'application/json',
                    access_token: process.env.ASAAS_API_KEY || '',
                  },
                },
              )

              if (response.status <= 200 && response.status > 300) {
                throw new Error(
                  `Falha ao atualizar a assinatura: ${response.statusText}`,
                )
              }
            }
            // Chamada pra api de pagamento "subscription" no caso de o usuário já ter seus dados de cartão salvos no banco;
            const response = await axios.post(
              `${process.env.PAYMENT_URL}/payment/subscription`,
              {
                billingType: 'CREDIT_CARD',
                cycle: 'MONTHLY',
                customer: paymentData.customerId,
                value: price,
                nextDueDate: formattedDate,
                creditCardToken: paymentData.creditCardInfo.creditCardToken,
              },
              {
                headers: {
                  'Content-Type': 'application/json',
                  access_token: process.env.ASAAS_API_KEY || '',
                },
              },
            )

            if (response.status <= 200 && response.status > 300) {
              throw new Error(
                `Falha ao gerar a cobrança: ${response.statusText}`,
              )
            }
          } else if (planId !== ownerPreviousPlan) {
            //Atualiza o valor do plano
            const response = await axios.post(
              `${process.env.PAYMENT_URL}/payment/subscription/${subscriptionId}`,
              {
                billingType: 'CREDIT_CARD',
                cycle: 'MONTHLY',
                customer: paymentData.customerId,
                value: price,
                nextDueDate: formattedDate,
                updatePendingPayments: true,
                creditCard: {
                  holderName: cardName,
                  number: cardNumber,
                  expiryMonth,
                  expiryYear,
                  ccv,
                },
                creditCardHolderInfo: {
                  name: cardName,
                  email,
                  phone: cellPhone,
                  cpfCnpj,
                  postalCode: address.zipCode,
                  addressNumber: address.streetNumber,
                },
              },
              {
                headers: {
                  'Content-Type': 'application/json',
                  access_token: process.env.ASAAS_API_KEY || '',
                },
              },
            )

            if (response.status <= 200 && response.status > 300) {
              throw new BadRequestException(
                'Não foi possível atualizar a assinatura.',
              )
            }
          }

          // Decrementar o número de créditos disponíveis do usuário;
          owner.adCredits = owner.adCredits - 1
          await owner.save()
        } else {
          throw new NotFoundException('Assinatura não encontrada.')
        }
      }
    }
  }

  private async handleLocationCreation(address: any, session: any) {
    await this.createOrUpdateLocation('city', address.city, session)
    await this.createOrUpdateLocation('uf', address.uf, session)
    await this.createOrUpdateLocation('streetName', address.streetName, session)
    await this.createOrUpdateLocation(
      'neighborhood',
      address.neighborhood,
      session,
    )
  }

  private async createOrUpdateLocation(
    category: string,
    name: string,
    session: any,
  ) {
    const foundLocation = await this.locationModel
      .findOne({ name, category })
      .lean()

    if (!foundLocation) {
      // Se a localização não existir, criar uma nova
      await this.locationModel.create([{ name, category }], { session })
    } else {
      // Se a localização já existir, não é necessário fazer nada
      return
    }
  }

  private async handlePropertyTypeCreation(propertyType: any, session: any) {
    const foundPropertyType = await this.propertyTypeModel
      .findOne({ name: propertyType })
      .lean()

    if (!foundPropertyType) {
      // Se o tipo de propriedade não existir, criar um novo
      await this.propertyTypeModel.create([{ name: propertyType }], { session })
    } else {
      // Se o tipo de propriedade já existir, não é necessário fazer nada
      return
    }
  }

  private async handleTagsCreation(tags: any[]) {
    if (tags && tags.length > 0) {
      const tagObjects: any = tags.map(tag => ({
        updateOne: {
          filter: { name: tag },
          update: {
            $inc: { amount: 1 },
          },
          upsert: true,
        },
      }))

      await this.tagModel.bulkWrite(tagObjects)
    }
  }

  private async createProperty(
    propertyData: any,
    ownerInfo: any,
    ownerId: string,
  ) {
    // Adds the owner id to property doc;
    propertyData.owner = ownerId

    // Adds owner info object to the property doc;
    propertyData.ownerInfo = ownerInfo

    // Creates the prperty on DB;
    const createdProperty = await this.propertyModel.create(propertyData)

    return createdProperty
  }
}
